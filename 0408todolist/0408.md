### 2024/04/08
- 함수정리
- 시계와 캘린더 구현
- 레이아웃 정리


시계구현
```
let clock = document.querySelector("#c");
function makeClock() {

const time = new Date();

let year = String(time.getFullYear());

let month = String(time.getMonth()+1);

let day = String(time.getDate());

let hour = String(time.getHours());

let min = String(time.getMinutes());

let sec = String(time.getSeconds());

clock.innerHTML = `${year}년${month}월${day}일 &nbsp ${hour}:${min}`;

}

makeClock();

setInterval(makeClock,1000);



```
	getTime = 1970년 1월 1일 UTC(협정 세계시) 자정부터 시간 차이를 통해 현재 시간을 반환.
	년월일시간분을 string으로 변환 후 innerHtml으로 id가 c인 태그에 삽입함.
	또한 실시간으로 시간이 갱신되는 것을 원하니 setInterval()함수를 통해 1000 -> 1초 주기마다 
    makeclock함수를 호출하게 함.





```
let list =[];

function arrManager(){

list.push(document.getElementById("list").value);

createList();

document.getElementById("list").value = "";

}

function createList(){

let div = document.createElement("div");

let pTag = document.createElement("p");

let divPtag = document.createElement("div");

let mainButton = document.createElement("button");

pTag.innerHTML = list[list.length-1];

SetAtt(mainButton,pTag,divPtag, div);

}

function SetAtt(mainButton,pTag,divPtag, div){

let parent = document.getElementById("parent");

divPtag.setAttribute("ondblclick","deleteList(this)");

mainButton.setAttribute("onclick","makeStyle(this)");

pTag.setAttribute("id","on");

parent.appendChild(div);

divPtag.appendChild(pTag);

div.appendChild(divPtag);

div.appendChild(mainButton);

}

function makeStyle(e){

let div = e.parentNode;

let divPtag = div.firstChild;

let p = divPtag.firstChild;

if(p.id === "on"){

divPtag.style.backgroundColor = "rgba(0, 0, 0, 0.27)"

p.style.textDecoration = "line-through";

p.id = "off"

e.innerHTML="✔️";

}

else{

divPtag.style.backgroundColor = "rgba(161, 182, 255, 0.44)"

p.style.textDecoration = "none";

p.id = "on";

e.innerHTML="";

}

}

  

function deleteList(e){

let p = e.firstChild;

let div = e.parentNode;

for(let i = 0; i < list.length; i++){

if(p.innerHTML == list[i]){list.splice(i,1); div.remove(); return;}

}

};
```

	 기존에 있던 보기 힘든 함수를 기능별로 정렬.

html
```
<!DOCTYPE html>

<html lang="ko">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>ToDoList</title>

<script src="list.js"></script>

<link rel="stylesheet" href="style.css">

<!-- font -->

<link rel="preconnect" href="https://fonts.googleapis.com">

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap" rel="stylesheet">

</head>

<body>

<div class="container">

<div class="topBar">

<div><p id="c"></p></div>

<div><h1>,</h1></div>

<div><button>-</button></div>

</div>

<div class ="middle">

<div></div>

<div class = "listOuterBox" id = "parent"></div>

<div></div>

</div>

<div class ="bottom">

<div></div>

<div><input type="text" id="list" placeholder="일정을 입력해주세요" onchange="arrManager()"></div>

<div></div>

</div>

</div>

  
  

</div>

</body>

<script src="clock.js"></script>

</html>
```

	그리드를 통해 화면을 분할하고 싶어 div들을 위치별로 분할하여 감싸주는 작업

css
```
*{

font-family: "Noto Sans KR", sans-serif;

margin: 0;

padding : 0;

font-size: 1vw;

}

.topBar{

display: grid;

grid-template-columns: 1fr 8fr 1fr;

grid-gap: 1vw;

margin-bottom: 1%;

}

.topBar>div{

width: 1fr;

height: 20vh;

/* border: solid; */

}

.topBar>:nth-child(2)>h1{

font-size: 5vw;

text-align: center;

}

.middle{

display: grid;

grid-template-columns: 1fr 8fr 1fr;

grid-gap: 1vw;

padding-bottom: 1%;

}

.middle>div{

height: 55vh;

/* border: solid; */

}

  

.bottom{

display: grid;

grid-template-columns: 1fr 8fr 1fr;

grid-gap: 1vw;

}

.bottom>div{

height: 15vh;

/* border: solid; */

text-align: center;

}

  
  

.bottom>:nth-child(2){

display: flex;

justify-content: center;

}

  

.bottom>:nth-child(2)>input[type=text]{

text-align: center;

width: 40vw;

height: 5vh;

margin: auto;

}

  

/* *일정 */

.listOuterBox>div{

margin: auto;

width:60vw;

height: 5vw;

display: flex;

}

.listOuterBox>div>div{

background-color: rgba(161, 182, 255, 0.44);

border-radius:10px ;

outline:none;

width: 60vw;

height: 5.5vh;

text-align: center;

}

.listOuterBox>div>div>p{

font-size: 1.5vw;

}

  

/* 버튼 */

.listOuterBox>div>:nth-child(2){

outline: none;

width: 2vw;

height: 4vh;

background: transparent;

cursor: pointer;

display: flex;

align-items:center;

margin: 0.3vw;

font-size: 3vh;

}
```

	최대한 클래스 접근자의 남용을 경계하며 grid를 통해 화면 배치.